{
    "fsRead": {
        "name": "fsRead",
        "description": "A tool for reading a file.\n * This tool returns the contents of a file, and the optional `readRange` determines what range of lines will be read from the specified file.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "path": {
                    "description": "Absolute path to a file, e.g. `/repo/file.py`.",
                    "type": "string"
                },
                "readRange": {
                    "description": "Optional parameter when reading files.\n * If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[startLine, -1]` shows all lines from `startLine` to the end of the file. If the whole file is too large, try reading 4000 lines at once, for example: after reading [1, 4000], read [4000, 8000] next and repeat.",
                    "items": {
                        "type": "integer"
                    },
                    "type": "array"
                }
            },
            "required": ["path"]
        }
    },
    "fsWrite": {
        "name": "fsWrite",
        "description": "A tool for creating and editing a file.\n * The `create` command will override the file at `path` if it already exists as a file, and otherwise create a new file\n * The `append` command will add content to the end of an existing file, automatically adding a newline if the file doesn't end with one. The file must exist.\n Notes for using the `strReplace` command:\n * The `oldStr` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!\n * If the `oldStr` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in `oldStr` to make it unique\n * The `newStr` parameter should contain the edited lines that should replace the `oldStr`. The `insert` command will insert `newStr` after `insertLine` and place it on its own line.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "explanation": {
                    "description": "One sentence explanation as to why this tool is being used, and how it contributes to the goal.",
                    "type": "string"
                },
                "command": {
                    "type": "string",
                    "enum": ["create", "strReplace", "insert", "append"],
                    "description": "The commands to run. Allowed options are: `create`, `strReplace`, `insert`, `append`."
                },
                "fileText": {
                    "description": "Required parameter of `create` command, with the content of the file to be created.",
                    "type": "string"
                },
                "insertLine": {
                    "description": "Required parameter of `insert` command. The `newStr` will be inserted AFTER the line `insertLine` of `path`.",
                    "type": "integer"
                },
                "newStr": {
                    "description": "Required parameter of `strReplace` command containing the new string. Required parameter of `insert` command containing the string to insert. Required parameter of `append` command containing the content to append to the file.",
                    "type": "string"
                },
                "oldStr": {
                    "description": "Required parameter of `strReplace` command containing the string in `path` to replace.",
                    "type": "string"
                },
                "path": {
                    "description": "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`.",
                    "type": "string"
                }
            },
            "required": ["command", "path"]
        }
    },
    "executeBash": {
        "name": "executeBash",
        "description": "Execute the specified bash command.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "Bash command to execute"
                },
                "cwd": {
                    "type": "string",
                    "description": "Parameter to set the current working directory for the bash command."
                }
            },
            "required": ["command", "cwd"]
        }
    },
    "listDirectory": {
        "name": "listDirectory",
        "description": "List the contents of a directory and its subdirectories.\n * Use this tool for discovery, before using more targeted tools like fsRead.\n *Useful to try to understand the file structure before diving deeper into specific files.\n *Can be used to explore the codebase.\n *Results clearly distinguish between files, directories or symlinks with [FILE], [DIR] and [LINK] prefixes.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "explanation": {
                    "description": "One sentence explanation as to why this tool is being used, and how it contributes to the goal.",
                    "type": "string"
                },
                "path": {
                    "type": "string",
                    "description": "Absolute path to a directory, e.g., `/repo`."
                },
                "maxDepth": {
                    "type": "integer",
                    "description": "Maximum depth to traverse when listing directories. Use `0` to list only the specified directory, `1` to include immediate subdirectories, etc. If it's not provided, it will list all subdirectories recursively."
                }
            },
            "required": ["path"]
        }
    },
    "grepSearch": {
        "name": "grepSearch",
        "description": "Fast text-based regex search that finds exact pattern matches within files or directories, utilizing the ripgrep command for efficient searching.\\nResults will be formatted in the style of ripgrep and can be configured to include line numbers and content.\\nTo avoid overwhelming output, the results are capped at 50 matches.\\nUse the include or exclude patterns to filter the search scope by file type or specific paths.\\n\\nThis is best for finding exact text matches or regex patterns.\\nMore precise than semantic search for finding specific strings or patterns.\\nThis is preferred over semantic search when we know the exact symbol/function name/etc. to search in some set of directories/file types.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "caseSensitive": {
                    "description": "Whether the search should be case sensitive",
                    "type": "boolean"
                },
                "excludePattern": {
                    "description": "Glob pattern for files to exclude",
                    "type": "string"
                },
                "explanation": {
                    "description": "One sentence explanation as to why this tool is being used, and how it contributes to the goal.",
                    "type": "string"
                },
                "includePattern": {
                    "description": "Glob pattern for files to include (e.g. '*.ts' for TypeScript files)",
                    "type": "string"
                },
                "query": {
                    "description": "The regex pattern to search for",
                    "type": "string"
                },
                "path": {
                    "description": "Absolute path to a directory, e.g., `/repo`.",
                    "type": "string"
                }
            },
            "required": ["query"]
        }
    }
}
