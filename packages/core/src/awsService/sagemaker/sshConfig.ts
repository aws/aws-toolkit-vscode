/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

import * as vscode from 'vscode'
import { SshConfig } from '../../shared/sshConfig'
import { Result } from '../../shared/utilities/result'
import { ToolkitError } from '../../shared/errors'
import { getLogger } from '../../shared/logger/logger'
import { getIdeProperties } from '../../shared/extensionUtilities'
import { showConfirmationMessage } from '../../shared/utilities/messages'
import { CancellationError } from '../../shared/utilities/timeoutUtils'
import { getSshConfigPath } from '../../shared/extensions/ssh'
import { fileExists, readFileAsString } from '../../shared/filesystemUtilities'
import fs from '../../shared/fs/fs'
import {
    SshConfigUpdateDeclinedMessage,
    SshConfigOpenedForEditMessage,
    SshConfigSyntaxErrorMessage,
    SshConfigRemovalFailedMessage,
    SshConfigUpdateFailedMessage,
    SshConfigModifiedMessage,
    SshConfigErrorCode,
    CurrentSshConfigVersion,
} from './constants'

const logger = getLogger('sagemaker')

/**
 * SageMaker-specific SSH configuration that handles outdated config detection and updates.
 * Extends the base SshConfig with SageMaker-specific validation logic.
 * Assumptions : 1. Toolkit will always know EXACTLY current SSH Config section which is upto date
 *               2. Users will not modify the ssh config generated by AWS Toolkit.
 */
export class SageMakerSshConfig extends SshConfig {
    public override async verifySSHHost(proxyCommand: string) {
        // Read the current state of SSH config
        const configStateResult = await this.readSshConfigState(proxyCommand)

        // If reading config state failed, return the error result
        if (configStateResult.isErr()) {
            return configStateResult
        }

        // Extract the state if section exists and if it's outdated
        const configState = configStateResult.ok()

        // Check if section exists and is outdated
        if (configState.hasSshSection && configState.isOutdated) {
            const updateResult = await this.updateOutdatedSection(proxyCommand)
            if (updateResult.isErr()) {
                return updateResult
            }
        }

        // Run validation
        const matchResult = await this.matchSshSection()
        if (matchResult.isErr()) {
            const sshError = matchResult.err()

            // If section existed or was just updated, the error is elsewhere in SSH config
            // Otherwise, the error is that the section doesn't exist (expected)
            if (configState.hasSshSection || !configState.isOutdated) {
                // Section exists and should be up-to-date, but validation still failed
                // This means the error is elsewhere in the SSH config
                try {
                    await this.promptOtherSshConfigError(sshError)
                    // User opened the file
                    return Result.err(
                        new ToolkitError(SshConfigOpenedForEditMessage(), {
                            code: SshConfigErrorCode.OPENED_FOR_EDIT,
                            details: { configPath: getSshConfigPath() },
                        })
                    )
                } catch (e) {
                    // User cancelled the "Open SSH Config" prompt (from promptOtherSshConfigError)
                    if (e instanceof CancellationError) {
                        const configPath = getSshConfigPath()
                        return Result.err(
                            new ToolkitError(SshConfigSyntaxErrorMessage(configPath), {
                                code: SshConfigErrorCode.EXTERNAL_ERROR,
                                details: { configPath },
                            })
                        )
                    }
                }
            }
            return matchResult
        }

        const configSection = matchResult.ok()
        const hasProxyCommand = configSection?.includes(proxyCommand)

        if (!hasProxyCommand) {
            try {
                await this.promptUserToConfigureSshConfig(configSection, proxyCommand)
            } catch (e) {
                // User cancelled or write failed
                return Result.err(
                    ToolkitError.chain(e, 'Failed to configure SSH config', {
                        code: SshConfigErrorCode.PROMPT_FAILED,
                    })
                )
            }
        }

        return Result.ok()
    }

    /**
     * Reads SSH config file once and determines its current state.
     *
     * State represents the current condition of the SSH config:
     * - hasSshSection: Does the sm_* section exist in the file?
     * - isOutdated: Is the section in an old/incorrect format?
     * - foundVersion: The SM SSH Config version found in the config
     *
     * @returns Result containing the state object or an error if file read fails
     */
    public async readSshConfigState(proxyCommand: string): Promise<
        Result<
            {
                hasSshSection: boolean // True if sm_* section exists
                isOutdated: boolean // True if section needs updating
                foundVersion?: string // Sagemaker Version found (e.g., 'v1', 'v2')
            },
            ToolkitError
        >
    > {
        const sshConfigPath = getSshConfigPath()

        // File not existing
        if (!(await fileExists(sshConfigPath))) {
            return Result.ok({ hasSshSection: false, isOutdated: false })
        }

        try {
            const configContent = await readFileAsString(sshConfigPath)
            const knownVersions = this.getKnownVersions()

            // Check which version exists in the config
            for (let i = 0; i < knownVersions.length; i++) {
                const versionGenerator = knownVersions[i]
                const versionContent = versionGenerator(proxyCommand).trim()

                if (configContent.includes(versionContent)) {
                    const versionNumber = i + 1 // Index 0 = v1, Index 1 = v2
                    const versionName = `v${versionNumber}`
                    const isCurrentVersion = versionNumber === CurrentSshConfigVersion

                    return Result.ok({
                        hasSshSection: true,
                        isOutdated: !isCurrentVersion,
                        foundVersion: versionName,
                    })
                }
            }

            // No known version found - either doesn't exist or user modified
            // Check if there's any sm_* Host section at all
            const hasHostSection = configContent.includes(`Host ${this.configHostName}`)

            if (hasHostSection) {
                // Section exists but doesn't match any known version - user modified
                return Result.ok({
                    hasSshSection: true,
                    isOutdated: true,
                    foundVersion: 'unknown',
                })
            }

            // No section found at all
            return Result.ok({ hasSshSection: false, isOutdated: false })
        } catch (e) {
            return Result.err(
                ToolkitError.chain(e, 'Failed to read SSH config file', {
                    code: SshConfigErrorCode.READ_FAILED,
                    details: { configPath: sshConfigPath },
                })
            )
        }
    }

    /**
     * Handles updating an outdated SSH config section.
     * Prompts user, removes old section, writes new section.
     *
     * @returns Result.ok() if updated successfully, Result.err() if user declined or update failed
     */
    private async updateOutdatedSection(proxyCommand: string): Promise<Result<void, ToolkitError>> {
        const shouldUpdate = await this.promptToUpdateSshConfig()

        if (!shouldUpdate) {
            // User declined the auto-update
            const configPath = getSshConfigPath()
            return Result.err(
                new ToolkitError(SshConfigUpdateDeclinedMessage(this.configHostName, configPath), {
                    code: SshConfigErrorCode.UPDATE_DECLINED,
                    details: { configHostName: this.configHostName, configPath },
                })
            )
        }

        try {
            // Remove the outdated section
            await this.removeSshConfigSection(proxyCommand)
            // Write the new section
            await this.writeSectionToConfig(proxyCommand)
            logger.info(`SSH config: successfully updated ${this.configHostName} section`)
            return Result.ok()
        } catch (e) {
            // Failed to update, handle the failure
            return await this.handleSshConfigUpdateFailure(e)
        }
    }

    /**
     * Prompts user to update the outdated SSH config section.
     * This is shown when the host section exists but is outdated.
     */
    private async promptToUpdateSshConfig(): Promise<boolean> {
        logger.warn(`SSH config: section is outdated for ${this.configHostName}`)

        const configPath = getSshConfigPath()
        const confirmTitle = `${getIdeProperties().company} Toolkit will replace the ${this.configHostName} section in ${configPath}`
        const confirmText = 'Update SSH config'

        const response = await showConfirmationMessage({ prompt: confirmTitle, confirm: confirmText })

        return response === true
    }

    /**
     * Prompts user when automatic SSH config update fails.
     * @throws CancellationError if user cancels
     */
    public async promptToFixUpdateFailure(updateError?: Error): Promise<void> {
        const sshConfigPath = getSshConfigPath()

        const message = updateError?.message || `Unable to update ${this.configHostName} section in ${sshConfigPath}.`

        const openButton = 'Open SSH Config'
        const cancelButton = 'Cancel'

        const response = await vscode.window.showErrorMessage(message, openButton, cancelButton)

        // User clicked Cancel or closed the dialog
        if (response !== openButton) {
            throw new CancellationError('user')
        }

        await vscode.window.showTextDocument(vscode.Uri.file(sshConfigPath))
    }

    /**
     * Prompts user when SSH config has errors elsewhere (not in toolkit's section).
     * @throws CancellationError if user cancels
     */
    public async promptOtherSshConfigError(sshError?: Error): Promise<void> {
        const sshConfigPath = getSshConfigPath()

        // Extract line number from SSH error message (best-effort).
        // Note: SSH error formats are not standardized and may vary across implementations.
        let errorDetails = ''
        if (sshError?.message) {
            const lineMatch = sshError.message.match(/line (\d+)/i)
            if (lineMatch) {
                errorDetails = `\n\nError at line ${lineMatch[1]}`
            }
        }

        const message = `There is an error in your ${sshConfigPath} file.${errorDetails}\n\nFix the error and try again.`

        const openButton = 'Open SSH Config'
        const cancelButton = 'Cancel'

        const response = await vscode.window.showErrorMessage(message, openButton, cancelButton)

        // User clicked Cancel or closed the dialog
        if (response !== openButton) {
            throw new CancellationError('user')
        }

        await vscode.window.showTextDocument(vscode.Uri.file(sshConfigPath))
    }

    /**
     * Removes the toolkit-managed SSH config section using version matching.
     *
     * This method checks for exact matches against known toolkit-generated configs
     * to ensure we only remove content we created, not user-defined content.
     */
    public async removeSshConfigSection(proxyCommand: string): Promise<void> {
        const sshConfigPath = getSshConfigPath()

        if (!(await fileExists(sshConfigPath))) {
            logger.info('SSH config: file does not exist, nothing to remove')
            return
        }

        try {
            const configContent = await readFileAsString(sshConfigPath)
            const knownVersionGenerators = this.getKnownVersions()

            // find and remove any known outdated version
            for (const versionGenerator of knownVersionGenerators) {
                const versionContent = versionGenerator(proxyCommand).trim()

                if (configContent.includes(versionContent)) {
                    // Found a known outdated version, remove it
                    const updatedContent = configContent.replace(versionContent, '')
                    await fs.writeFile(sshConfigPath, updatedContent, { atomic: true })
                    logger.info(`SSH config: removed ${this.configHostName} section`)
                    return
                }
            }

            // Check if there's any Host section at all
            if (configContent.includes(`Host ${this.configHostName}`)) {
                // Section exists but doesn't match any known version - user modified it
                throw new ToolkitError(SshConfigModifiedMessage(this.configHostName), {
                    code: SshConfigErrorCode.MODIFIED,
                })
            }

            // No section found, nothing to remove
            logger.warn(`SSH config: no ${this.configHostName} section found to remove`)
        } catch (e) {
            throw ToolkitError.chain(e, SshConfigRemovalFailedMessage(this.configHostName, sshConfigPath), {
                code: SshConfigErrorCode.REMOVAL_FAILED,
            })
        }
    }

    /**
     * Handles SSH config update failure by prompting user to fix manually.
     */
    private async handleSshConfigUpdateFailure(updateError: unknown): Promise<Result<void, ToolkitError>> {
        try {
            // Prompt user to open SSH config file to fix manually
            await this.promptToFixUpdateFailure(updateError instanceof Error ? updateError : undefined)

            // User opened the file
            const configOpenedError = new ToolkitError(SshConfigOpenedForEditMessage(), {
                code: SshConfigErrorCode.OPENED_FOR_EDIT,
                details: { configPath: getSshConfigPath() },
            })
            return Result.err(configOpenedError)
        } catch (promptError) {
            // User cancelled the "Open SSH Config" prompt (from promptToFixUpdateFailure)
            if (promptError instanceof CancellationError) {
                const configPath = getSshConfigPath()
                return Result.err(
                    ToolkitError.chain(updateError, SshConfigUpdateFailedMessage(configPath, this.configHostName), {
                        code: SshConfigErrorCode.UPDATE_FAILED,
                        details: {
                            configHostName: this.configHostName,
                            configPath,
                        },
                    })
                )
            }

            // Unexpected error during prompt
            return Result.err(
                ToolkitError.chain(promptError, 'Unexpected error while handling SSH config update failure', {
                    code: SshConfigErrorCode.ERROR_HANDLING_FAILED,
                })
            )
        }
    }

    /**
     * Version 1: format with User '%r' directive.
     * Used in earlier versions of the toolkit.
     */
    private createSSHConfigV1(proxyCommand: string): string {
        return `
# Created by AWS Toolkit for VSCode. https://github.com/aws/aws-toolkit-vscode
Host ${this.configHostName}
    ForwardAgent yes
    AddKeysToAgent yes
    StrictHostKeyChecking accept-new
    ProxyCommand ${proxyCommand}
    User '%r'`
    }

    /**
     * Version 2: Current latest version used by the toolkit.
     */
    private createSSHConfigV2(proxyCommand: string): string {
        return `
# Created by AWS Toolkit for VSCode. https://github.com/aws/aws-toolkit-vscode
Host ${this.configHostName}
    ForwardAgent yes
    AddKeysToAgent yes
    StrictHostKeyChecking accept-new
    ProxyCommand ${proxyCommand}`
    }

    /**
     * Creates SageMaker-specific SSH config section ALWAYS current version.
     * Delegates to the current version generator.
     */
    protected override createSSHConfigSection(proxyCommand: string): string {
        return this.createSSHConfigV2(proxyCommand)
    }

    /**
     * Returns all known SSH config versions in order (oldest to newest).
     * Each version is a function that generates the config given a proxy command.
     */
    private getKnownVersions(): Array<(proxyCommand: string) => string> {
        return [
            this.createSSHConfigV1.bind(this), // v1 (old)
            this.createSSHConfigV2.bind(this), // v2 (current)
        ]
    }
}
